name: "ðŸ·ï¸ Create Staging Stable Tag"

on:
    workflow_dispatch:
        inputs:
            version:
                description: "Stable version X.Y.Z (optional; defaults to pyproject.toml base X.Y.Z)"
                required: false
                type: string
            skip_bump_commit:
                description: "Skip bump/commit/push; only create & push the stable tag on current HEAD (requires pyproject.toml already matches the stable version)"
                required: false
                default: "false"
                type: choice
                options:
                    - "false"
                    - "true"
            auto_promote:
                description: "After tagging, auto-promote to rapidkit-core via PR"
                required: false
                default: "false"
                type: choice
                options:
                    - "false"
                    - "true"
            dry_run:
                description: "Only compute and validate; do not commit/tag/push"
                required: false
                default: "false"
                type: choice
                options:
                    - "false"
                    - "true"

concurrency:
    group: community-staging-tag-stable-${{ github.ref }}
    cancel-in-progress: true

jobs:
    tag:
        runs-on: ubuntu-latest
        permissions:
            contents: write
        steps:
            - name: Checkout
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0
                  fetch-tags: true
                  persist-credentials: false


            - name: Remove checkout auth header
              run: |
                  set -euo pipefail
                  # actions/checkout may set an auth extraheader for GITHUB_TOKEN (github-actions[bot]).
                  # Unset it so our PAT remote URL is actually used for fetch/push.
                  git config --local --unset-all http.https://github.com/.extraheader || true


            - name: Install Poetry
              uses: snok/install-poetry@v1
              with:
                  version: "2.2.1"
                  virtualenvs-in-project: true
                  virtualenvs-create: true

            - name: Configure git identity
              run: |
                  set -euo pipefail
                  git config --global user.name "rapidkit-bot"
                  git config --global user.email "actions@users.noreply.github.com"

            - name: Resolve stable version
              id: v
              run: |
                  set -euo pipefail

                  input="${{ inputs.version }}"
                  if [[ -n "$input" ]]; then
                      base="$input"
                  else
                      raw=$(awk -F '"' '/^version =/ {print $2; exit}' pyproject.toml)
                      base=$(echo "$raw" | grep -Eo '^[0-9]+\.[0-9]+\.[0-9]+' || true)
                      if [[ -z "$base" ]]; then
                          echo "Unable to resolve base X.Y.Z from pyproject.toml version: $raw" >&2
                          exit 1
                      fi
                  fi

                  if ! [[ "$base" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                      echo "Invalid stable version (expected X.Y.Z): $base" >&2
                      exit 1
                  fi

                  echo "stable_version=$base" >> "$GITHUB_OUTPUT"
                  echo "stable_tag=v$base" >> "$GITHUB_OUTPUT"

            - name: Validate tag does not already exist
              run: |
                  set -euo pipefail
                  tag="${{ steps.v.outputs.stable_tag }}"
                  # actions/checkout runs with persist-credentials=false, so origin has no auth.
                  # Ensure fetch works for private repos by using the workflow's GITHUB_TOKEN.
                  token="${{ github.token }}"
                  git remote set-url origin "https://x-access-token:${token}@github.com/${GITHUB_REPOSITORY}.git"
                  git fetch --tags --force
                  if git rev-parse -q --verify "refs/tags/$tag" >/dev/null; then
                      echo "Tag already exists: $tag" >&2
                      exit 1
                  fi

            - name: Show stable tag
              run: |
                  echo "Stable version: ${{ steps.v.outputs.stable_version }}"
                  echo "Stable tag: ${{ steps.v.outputs.stable_tag }}"

            - name: Validate pyproject already at stable version (skip bump)
              if: ${{ inputs.dry_run != 'true' && inputs.skip_bump_commit == 'true' }}
              run: |
                  set -euo pipefail
                  expected="${{ steps.v.outputs.stable_version }}"
                  raw=$(awk -F '"' '/^version =/ {print $2; exit}' pyproject.toml)
                  current=$(echo "$raw" | grep -Eo '^[0-9]+\.[0-9]+\.[0-9]+' || true)
                  if [[ -z "$current" ]]; then
                      echo "Unable to resolve current X.Y.Z from pyproject.toml version: $raw" >&2
                      exit 1
                  fi
                  if [[ "$current" != "$expected" ]]; then
                      echo "skip_bump_commit=true but pyproject.toml is $current (expected $expected)." >&2
                      echo "Either bump version first (or set skip_bump_commit=false), then re-run." >&2
                      exit 1
                  fi

            - name: Bump pyproject version (stable) and commit
              if: ${{ inputs.dry_run != 'true' && inputs.skip_bump_commit != 'true' }}
              run: |
                  set -euo pipefail

                  stable="${{ steps.v.outputs.stable_version }}"
                  echo "Bumping project version to: $stable"

                  poetry version "$stable"

                  if poetry lock --help 2>/dev/null | grep -q -- '--no-update'; then
                      poetry lock --no-update
                  else
                      poetry lock
                  fi

                  git add pyproject.toml poetry.lock
                  if git diff --cached --quiet; then
                      echo "No version changes to commit (already at $stable)."
                  else
                      git commit -m "chore(release): bump version to $stable"
                  fi

            - name: Create and push stable tag
              if: ${{ inputs.dry_run != 'true' }}
              env:
                  STAGING_TAG_PUSH_TOKEN: ${{ secrets.STAGING_TAG_PUSH_TOKEN }}
              run: |
                  set -euo pipefail

                  tag="${{ steps.v.outputs.stable_tag }}"
                  stable="${{ steps.v.outputs.stable_version }}"

                  git tag -a "$tag" -m "Stable: $tag"

                  if [[ -n "${STAGING_TAG_PUSH_TOKEN:-}" ]]; then
                      # Use PAT so the tag push can trigger downstream workflows.
                      git remote set-url origin "https://x-access-token:${STAGING_TAG_PUSH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
                  else
                      echo "NOTE: STAGING_TAG_PUSH_TOKEN is not set. Pushing tag with GITHUB_TOKEN may not trigger other workflows." >&2
                      echo "      If you want tag -> publish to auto-run, add a PAT secret named STAGING_TAG_PUSH_TOKEN (repo+workflow)." >&2
                  fi

                  # Push version bump commit first (so the tag points at the correct pyproject version)
                  # unless skip_bump_commit=true.
                  if [[ "${{ inputs.skip_bump_commit }}" != "true" ]]; then
                      git push origin "HEAD:${GITHUB_REF_NAME}"
                  else
                      echo "skip_bump_commit=true: not pushing a version bump commit."
                  fi
                  git push origin "$tag"

                  echo "Pushed stable tag: $tag (version $stable)"

            - name: Add core remote (for auto-promote)
              if: ${{ inputs.dry_run != 'true' && inputs.auto_promote == 'true' }}
              env:
                  CORE_PUSH_TOKEN: ${{ secrets.CORE_PUSH_TOKEN }}
              run: |
                  set -euo pipefail
                  if [[ -z "${CORE_PUSH_TOKEN:-}" ]]; then
                      echo "Missing CORE_PUSH_TOKEN secret" >&2
                      echo "Create a fine-grained PAT with permissions for getrapidkit/rapidkit-core: Contents=Read/Write, Pull requests=Read/Write." >&2
                      exit 1
                  fi
                  remote_url="https://x-access-token:${CORE_PUSH_TOKEN}@github.com/getrapidkit/rapidkit-core.git"
                  if git remote get-url core >/dev/null 2>&1; then
                      git remote set-url core "$remote_url"
                  else
                      git remote add core "$remote_url"
                  fi

            - name: Validate token can access rapidkit-core (auto-promote)
              if: ${{ inputs.dry_run != 'true' && inputs.auto_promote == 'true' }}
              env:
                  CORE_PUSH_TOKEN: ${{ secrets.CORE_PUSH_TOKEN }}
              run: |
                  set -euo pipefail

                  # Helpful diagnostics (mask token in logs)
                  core_url=$(git remote get-url core 2>/dev/null || true)
                  if [[ -n "${core_url:-}" ]]; then
                      echo "core remote: $(echo "$core_url" | sed -E 's/x-access-token:[^@]+@/x-access-token:***@/g')"
                  fi

                  code=$(curl -sS -o /dev/null -w "%{http_code}" \
                    -H "Authorization: Bearer ${CORE_PUSH_TOKEN}" \
                    -H "X-GitHub-Api-Version: 2022-11-28" \
                    "https://api.github.com/repos/getrapidkit/rapidkit-core")
                  echo "Token repo metadata access check for getrapidkit/rapidkit-core: HTTP ${code}"
                  if [[ "${code}" != "200" ]]; then
                      echo "CORE_PUSH_TOKEN cannot access getrapidkit/rapidkit-core (expected 200)." >&2
                      echo "Fix: ensure the fine-grained PAT is granted access to the rapidkit-core repository and has Contents=Read/Write + Pull requests=Read/Write." >&2
                      echo "If the org uses SSO/SAML, ensure the token is authorized for the org." >&2
                      exit 1
                  fi

            - name: Fetch core main (for workflow restore)
              if: ${{ inputs.dry_run != 'true' && inputs.auto_promote == 'true' }}
              run: |
                  set -euo pipefail
                  git fetch core main --prune

            - name: Create promote branch from stable tag
              if: ${{ inputs.dry_run != 'true' && inputs.auto_promote == 'true' }}
              env:
                  STABLE_TAG: ${{ steps.v.outputs.stable_tag }}
              run: |
                  set -euo pipefail
                  safe="$STABLE_TAG"
                  safe="${safe//\//-}"
                  safe="${safe// /-}"
                  safe="${safe//:/-}"
                  safe="${safe//#/}"
                  promote_branch="promote/${safe}"
                  echo "PROMOTE_BRANCH=$promote_branch" >> "$GITHUB_ENV"
                  git checkout -B "$promote_branch" "$STABLE_TAG"

            - name: Keep core workflows authoritative (auto-promote)
              if: ${{ inputs.dry_run != 'true' && inputs.auto_promote == 'true' }}
              run: |
                  set -euo pipefail

                  if git cat-file -e "core/main:.github/workflows" 2>/dev/null; then
                      git checkout "core/main" -- .github/workflows
                  else
                      rm -rf .github/workflows || true
                  fi

                  if ! git diff --quiet -- .github/workflows 2>/dev/null; then
                      git add -A .github/workflows
                      git commit -m "chore: keep core GitHub workflows"
                  else
                      echo "Workflows already match core/main."
                  fi

            - name: Push promote branch to core (auto-promote)
              if: ${{ inputs.dry_run != 'true' && inputs.auto_promote == 'true' }}
              run: |
                  set -euo pipefail
                  git push core "HEAD:${PROMOTE_BRANCH}"

            - name: Create PR in core (auto-promote)
              if: ${{ inputs.dry_run != 'true' && inputs.auto_promote == 'true' }}
              env:
                  CORE_PUSH_TOKEN: ${{ secrets.CORE_PUSH_TOKEN }}
                  SOURCE_REF: ${{ steps.v.outputs.stable_tag }}
              run: |
                  set -euo pipefail

                  owner="getrapidkit"
                  repo="rapidkit-core"
                  head="${owner}:${PROMOTE_BRANCH}"

                  title="Promote ${SOURCE_REF} â†’ main"
                  body=$'Automated promote from staging stable tag '\''${SOURCE_REF}'\''.'"\n\n"$'- Keeps rapidkit-core workflows authoritative by restoring .github/workflows from '\''main'\''.'

                                    TITLE="$title" HEAD="$head" BASE="main" BODY="$body" \
                                        python3 -c 'import json, os; print(json.dumps({"title": os.environ["TITLE"], "head": os.environ["HEAD"], "base": os.environ["BASE"], "body": os.environ["BODY"]}))' \
                                        > /tmp/pr-payload.json

                  code=$(curl -sS -o /tmp/pr.json -w "%{http_code}" \
                    -H "Authorization: Bearer ${CORE_PUSH_TOKEN}" \
                    -H "X-GitHub-Api-Version: 2022-11-28" \
                    -H "Content-Type: application/json" \
                    -d @/tmp/pr-payload.json \
                    "https://api.github.com/repos/${owner}/${repo}/pulls")

                  if [[ "$code" = "201" ]]; then
                      url=$(python3 -c 'import json; print(json.load(open("/tmp/pr.json"))["html_url"])')
                      echo "Created PR: $url"
                      exit 0
                  fi

                  echo "PR create returned HTTP $code" >&2
                  cat /tmp/pr.json >&2 || true
                  echo "If a PR already exists for this branch, open it from the rapidkit-core UI." >&2
                  exit 0
